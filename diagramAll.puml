[plantuml]
----
@startuml
start
:Create the workspace folder;
:Create the main module. Initialize the module;
:Create go.mod. Add a dependency on the github.com/mobiledatabooks/go-fetch/fetcher module;
:Create fetchall.go in the fetchall directory;
:Now, run the main program;
:Create the workspace;
:Run the program in the workspace directory;
:Download and modify the github.com/mobiledatabooks/go-fetch module;
:Clone the repository;
:Working with the local copy;
:Add the new function.;
:Modify the main program to use the function.;
:Make a change in one module and use it in another.;
stop
@enduml
----

[plantuml]
----
@startuml
start
title Traditional Workflow #1

package "Developer" {
    :Task;
    ' -> gcloud auth login;
    note left
    User wants to add a feature in an upstream module 
    and make use of the feature in their own module
    end note
    :Step 1;
    note left
    Open the two modules in their editor through gopls, 
    which creates a supermodule requiring and replacing 
    both of the modules;
    end note
    :Step 2;
    note left
    The editor tooling and builds done through the editor 
    will use the build list from the supermodule, 
    but the user will not have access to the supermodule 
    outside their editor;
    end note
     :Step 3;
     note left
    Change their go.mod to add a replace, 
    which will be reflected in both the editor 
    and their go command invocations, 
    but this is a change they will need to remember 
    to make every time they want to use the feature;
    end note
}
stop
@enduml
----

[plantuml]
----
@startuml
start
title Traditional Workflow #1

package "Developer" {
    :Step 1;
    note left
    create directory structure 
    for modules
    end note
    :Step 2;
    note left
    create go.mod file
    end note
    :Step 3;
    note left
    add module declaration
    end note
    :Step 4;
    note left
    add require directive
    end note
    :Step 5;
    note left
    add replace directive
    end note
    :Step 6;
    note left
    add go build command
    end note
   :Step 7;
    note left
    add go install command
    end note
    :Step 8;
    note left
    add go test command
    end note
}
stop
@enduml
----
Making a Change that Requires a New Dependency. How to add a new dependency to a module.

The user wants to add a new dependency to a module. They open the module in their editor through gopls, which creates a supermodule requiring the module. The editor tooling and builds done through the editor will use the build list from the supermodule, but the user will not have access to the supermodule outside their editor. The user can change their go.mod to add the dependency, which will be reflected in both the editor and their go command invocations.
create plantuml diagram:

[plantuml]
----
@startuml
start
:user wants to add a new dependency to a module;
:open the module in their editor through gopls, which creates a supermodule requiring the module;
:the editor tooling and builds done through the editor will use the build list from the supermodule, but the user will not have access to the supermodule outside their editor;
:change their go.mod to add the dependency, which will be reflected in both the editor and their go command invocations;
stop
@enduml
----

Making a Change that Requires a New Module. How to add a new module to a workspace.

The user wants to add a new module to a workspace. They create a new directory for the module and add a go.mod file to it. They open the module in their editor through gopls, which creates a supermodule requiring the module. The editor tooling and builds done through the editor will use the build list from the supermodule, but the user will not have access to the supermodule outside their editor. The user can change their go.mod to add the module, which will be reflected in both the editor and their go command invocations.
create plantuml diagram:

[plantuml]
----
@startuml
start
:user wants to add a new module to a workspace;
:create a new directory for the module and add a go.mod file to it;
:open the module in their editor through gopls, which creates a supermodule requiring the module;
:the editor tooling and builds done through the editor will use the build list from the supermodule, but the user will not have access to the supermodule outside their editor;
:change their go.mod to add the module, which will be reflected in both the editor and their go command invocations;
stop
@enduml
----

Making a Change that Requires a New Package. How to add a new package to a module.

The user wants to add a new package to a module. They create a new directory for the package and add the necessary files to it. They open the module in their editor through gopls, which creates a supermodule requiring the module. The editor tooling and builds done through the editor will use the build list from the supermodule, but the user will not have access to the supermodule outside their editor. The user can change their go.mod to add the package, which will be reflected in both the editor and their go command invocations.
create plantuml diagram:

[plantuml]
----
@startuml
start
:user wants to add a new package to a module;
:create a new directory for the package and add the necessary files to it;
:open the module in their editor through gopls, which creates a supermodule requiring the module;
:the editor tooling and builds done through the editor will use the build list from the supermodule, but the user will not have access to the supermodule outside their editor;
:change their go.mod to add the package, which will be reflected in both the editor and their go command invocations;
stop
@enduml
----

[plantuml]
----
@startuml
start
if (First step) then (nth step)
:Do something;
elseif (nth+1 step) then (last step)
:Do something else;
endif
stop
@enduml
----
[plantuml]
----
@startuml
start
:create supermodule;
:open editor;
:add feature in upstream module;
:use feature in own module;
:editor tooling and builds use build list from supermodule;
:change go.mod to add replace;
:reflect change in editor and go command invocations;
stop
@enduml

----

[plantuml]
----
@startuml
start
:Login;
-> gcloud auth login;
note left
    mkdir go-workspace
    cd go-workspace
end note
stop

@enduml
----
[plantuml]
----
@startuml
start

:Login;
-> gcloud auth login;
note left
    mkdir go-workspace
    cd go-workspace
end note
if (Login Successful) then (Yes)

:Create;
-> gcloud projects create gcp-go-api;
note right
Create a new project
end note

:View;
-> gcloud projects list;
note left
View your project
end note

:Default;
-> gcloud config set project gcp-go-api;
note right
Set your project 
as the default
end note

:Billing;
-> gcloud beta billing projects;
note left
Enable billing 
for your project
end note

:Enable;
-> gcloud services enable sheets.googleapis.com;
note right
Enable the Google Sheets API
end note


:Environment;
-> export GOOGLE_APPLICATION_CREDENTIALS=./credentials.json;
note left
Set the environment variable 
GOOGLE_APPLICATION_CREDENTIALS 
to the path of the JSON file 
that contains your account key
end note

:Verify;
-> echo $GOOGLE_APPLICATION_CREDENTIALS;
note right
Verify that 
the environment 
variable is set
end note

else (No)


endif
stop

@enduml
----


[plantuml]
----
@startuml
start

title Go (Golang) Multi-Module Workspaces: The Easy Way to Build and Run Code in Multiple Module

package "Developer" {
    :1. Create the workspace folder;
    -> go-workspace;
    note left
        mkdir go-workspace
        cd go-workspace
    end note
    :2. Create the main module;
    -> fetchall;
    note left
        mkdir fetchall
        cd fetchall
    end note
    :3. Initialize the module;
    -> go.mod;
    note left
        go mod init mobiledatabooks.com/fetchall

        The resulting go.mod:
            module mobiledatabooks.com/fetchall

            go 1.19
    end note
    :4. Create fetchall.go;
    -> fetchall.go;
    note left
package main
import (
	"os"
	"github.com/mobiledatabooks/go-fetch/fetcher"
)

func main() {
	for _, url := range os.Args[1:] {
		fetcher.FetchWithBuffer(url)
	}
}
    end note

    :5. Add a module dependency;
    -> go mod tidy;
    note left
        Add a dependency on the 
        github.com/mobiledatabooks/go-fetch/fetcher 
        module

        The resulting go.mod:
            module mobiledatabooks.com/fetchall

            go 1.19

            require github.com/mobiledatabooks/go-fetch/fetcher 
            v0.0.0-20220821205820-5b3e6cfec1a4

    end note

    :6. Now, run the main program;
    -> go run main.go;
    note left
go run fetchall.go \
https://golang.org  \
http://gopl.io  \
https://godoc.org

fetcher.FetchWithBuffer: Fetching URLs...
HTTP status: 200 OK
HTTP status: 200 OK
HTTP status: 200 OK
3.03s elapsed
    end note

    :7. Create the workspace;
   -> go.work;
    note left 
    The go work init command tells go to create 
    a go.work file for a workspace containing 
    the modules in the ./fetchall directory.

        go work init ./fetchall

go.work:
---
go 1.19
use (
	./fetchall
)
---
    end note
    :8. Run the program in the workspace directory;
    -> go run mobiledatabooks.com/fetchall;
    note left
➜  go-workspace git:(main) ✗ go run mobiledatabooks.com/fetchall  \
https://golang.org \
http://gopl.io https://godoc.org
fetcher.FetchWithBuffer: Fetching URLs...
HTTP status: 200 OK
HTTP status: 200 OK
HTTP status: 200 OK
1.50s elapsed
    end note
    :Download and modify the github.com/mobiledatabooks/go-fetch module;
    
    :9. Clone the repository;
    -> git clone;
    note left 
    cd go-workspace
    git clone https://github.com/mobiledatabooks/go-fetch.git

    It creates go-fetch directory:
---
➜  go-workspace git:(main) ✗ tree
.
├── LICENSE
├── README.md
├── fetchall
│   ├── fetchall.go
│   ├── go.mod
│   └── go.sum
├── go-fetch
│   ├── LICENSE
│   ├── README.md
│   ├── fetcher
│   │   ├── fetch.go
│   │   ├── fetchConcurrent.go
│   │   ├── fetchWithBuffer.go
│   │   └── go.mod
│   ├── go.mod
│   ├── go.sum
│   ├── main
│   ├── main.go
├── go.work
├── go.work.sum
---
    end note
    :10. Add the module to the workspace;
    -> go work use;
    note left 
go work use ./go-fetch
go work use ./go-fetch/fetcher

go.work:
---
go 1.19

use (
	./fetchall
	./go-fetch
	./go-fetch/fetcher
)
---
    end note
    :Working with the local copy;
    :12. Add the new function.;
    -> FetchConcurrent;
    note left 
// Fetch prints the content found at each specified URL.
package fetcher

import (
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"time"
)

// !+
func FetchConcurrent(url string, ch chan<- string) {
	start := time.Now()
	resp, err := http.Get(url)
	if err != nil {
		ch <- fmt.Sprint(err) // send to channel ch
		return
	}

	nbytes, err := io.Copy(ioutil.Discard, resp.Body)
	resp.Body.Close() // don't leak resources
	if err != nil {
		ch <- fmt.Sprintf("while reading %s: %v", url, err)
		return
	}
	secs := time.Since(start).Seconds()
	ch <- fmt.Sprintf("%.2fs  %7d  %s", secs, nbytes, url)
}

    end note

    :13. Modify the main program to use the function.;
    -> main/FetchConcurrent;
    note left 
// Fetchall fetches URLs in parallel and reports their times and sizes.
package main

import (
	"fmt"
	"os"
	"time"

	"github.com/mobiledatabooks/go-fetch/fetcher"
)
func main() {
	fmt.Println("fetcher.FetchConcurrent: Fetching URLs...")
	start = time.Now()
	ch := make(chan string)
	for _, url := range os.Args[1:] {
		go fetcher.FetchConcurrent(url, ch) // start a goroutine
	}
	for range os.Args[1:] {
		fmt.Println(<-ch) // receive from channel ch
	}
	fmt.Printf("%.2fs elapsed\n", time.Since(start).Seconds())
}


    end note  

    :14. Modify the fetchall/go.mod to use the local module.;
    -> fetchall/go.mod;
    note left 

    remove require github.com/mobiledatabooks/go-fetch/fetcher v0.0.0-20220821205820-5b3e6cfec1a4
go.mod:
---    
module mobiledatabooks.com/fetchall

go 1.19
---
    end note 

    :15. Run the code in the workspace;
    -> go run mobiledatabooks.com/fetchall;
    note left 
➜  go-workspace git:(main) ✗ go run mobiledatabooks.com/fetchall  \
https://golang.org \
http://gopl.io https://godoc.org   

fetcher.FetchConcurrent: Fetching URLs...
HTTP status: 200 OK
0.08s     4154  http://gopl.io
HTTP status: 200 OK
0.16s    59868  https://golang.org
HTTP status: 200 OK
0.27s    17461  https://godoc.org
0.27s elapsed

    end note 
}
stop
@enduml
----
